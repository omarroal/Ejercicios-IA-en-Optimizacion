# -*- coding: utf-8 -*-
"""practica2_IAO.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1siCvecWlv2z9gmnfq1pQVhQRxDtGjjHJ

# Inteligencia Artificial en Optimizacion
# Práctica Python
# OMAR RODRIGUEZ ALVAREZ

# 1) 
Suponiendo que tenemos un problema de optimización con dos objetivos (Max Min), cuyos valores se encuentran en los rangos [0,10] y [100, 1000] respectivamente, generar con Python 100 soluciones no dominadas (en el
espacio de los objetivos) y representarlas gráficamente
"""

import random
import matplotlib.pyplot as plt

# Generar una solución aleatoria en el espacio de objetivos
def generar_solucion():
    objetivo1 = random.uniform(0, 10)
    objetivo2 = random.uniform(100, 1000)
    return (objetivo1, objetivo2)

# Comprobar si una solución domina a otra
def domina(solucion1, solucion2):
    return solucion1[0] >= solucion2[0] and solucion1[1] <= solucion2[1]

# Generar soluciones no dominadas
def generar_soluciones_no_dominadas(soluciones):
    soluciones_no_dominadas = []
    for solucion in soluciones:
        if not any(domina(solucion, otra_solucion) for otra_solucion in soluciones_no_dominadas):
            soluciones_no_dominadas.append(solucion)
    return soluciones_no_dominadas

# Generar soluciones aleatorias hasta obtener 100 soluciones no dominadas
soluciones = []
while len(soluciones) < 100:
    solucion = generar_solucion()
    if not any(domina(solucion, otra_solucion) for otra_solucion in soluciones):
        soluciones.append(solucion)

# Obtener las soluciones no dominadas
soluciones_no_dominadas = generar_soluciones_no_dominadas(soluciones)

# Representar gráficamente las soluciones no dominadas
objetivo1 = [solucion[0] for solucion in soluciones_no_dominadas]
objetivo2 = [solucion[1] for solucion in soluciones_no_dominadas]

plt.scatter(objetivo1, objetivo2, c='blue', marker='o')

plt.xlabel('Objetivo 1')
plt.ylabel('Objetivo 2')
plt.title('Soluciones No Dominadas')
plt.grid(True)
plt.show()

"""# 2) 
Obtener 5 soluciones (en el espacio de los objetivos) dominadas por algunas de las soluciones generadas en 1) y añadirlas al gráfico anterior, representándolas en otro color. Determinar, para cada una de estas 5 soluciones, cuántas soluciones le dominan y a cuántas dominan.
"""

import random
import matplotlib.pyplot as plt

# Generar una solución aleatoria en el espacio de objetivos
def generar_solucion():
    objetivo1 = random.uniform(0, 10)
    objetivo2 = random.uniform(100, 1000)
    return (objetivo1, objetivo2)

# Comprobar si una solución domina a otra
def domina(solucion1, solucion2):
    return solucion1[0] >= solucion2[0] and solucion1[1] <= solucion2[1]

# Generar soluciones no dominadas
def generar_soluciones_no_dominadas(soluciones):
    soluciones_no_dominadas = []
    for solucion in soluciones:
        if not any(domina(solucion, otra_solucion) for otra_solucion in soluciones_no_dominadas):
            soluciones_no_dominadas.append(solucion)
    return soluciones_no_dominadas

# Generar soluciones aleatorias hasta obtener 100 soluciones no dominadas
soluciones = []
while len(soluciones) < 100:
    solucion = generar_solucion()
    if not any(domina(solucion, otra_solucion) for otra_solucion in soluciones):
        soluciones.append(solucion)

# Obtener las soluciones no dominadas
soluciones_no_dominadas = generar_soluciones_no_dominadas(soluciones)

# Representar gráficamente las soluciones no dominadas
objetivo1 = [solucion[0] for solucion in soluciones_no_dominadas]
objetivo2 = [solucion[1] for solucion in soluciones_no_dominadas]

plt.scatter(objetivo1, objetivo2, c='blue', marker='o')

# Obtener 5 soluciones dominadas
soluciones_dominadas = []
for i in range(5):
    solucion_dominante = random.choice(soluciones_no_dominadas)
    solucion_dominada = generar_solucion()
    while not domina(solucion_dominante, solucion_dominada):
        solucion_dominada = generar_solucion()
    soluciones_dominadas.append(solucion_dominada)

# Agregar las soluciones dominadas al gráfico en otro color
objetivo1_dominadas = [solucion[0] for solucion in soluciones_dominadas]
objetivo2_dominadas = [solucion[1] for solucion in soluciones_dominadas]

plt.scatter(objetivo1_dominadas, objetivo2_dominadas, c='red', marker='o')

plt.xlabel('Objetivo 1')
plt.ylabel('Objetivo 2')
plt.title('Soluciones No Dominadas')
plt.grid(True)
plt.show()

# Calcular el número de soluciones que dominan y que son dominadas por cada una de las soluciones dominadas
num_soluciones_dominantes = []
num_soluciones_dominadas = []
for solucion_dominada in soluciones_dominadas:
    count_dominantes = sum(domina(solucion, solucion_dominada) for solucion in soluciones)
    count_dominadas = sum(domina(solucion_dominada, solucion) for solucion in soluciones)
    num_soluciones_dominantes.append(count_dominantes)
    num_soluciones_dominadas.append(count_dominadas)

# Mostrar los resultados
for i, solucion_dominada in enumerate(soluciones_dominadas):
    print(f"Solución dominada {i+1}:")
    print(f"Número de soluciones que le dominan: {num_soluciones_dominantes[i]}")
    print(f"Número de soluciones que domina: {num_soluciones_dominadas[i]}")
    print()

"""# 3) 
Obtener 5 soluciones (en el espacio de los objetivos) que dominen a algunas de las soluciones generadas en 1) y añadirlas al gráfico anterior, representándolas en otro color. Determinar, para cada una de estas 5 soluciones, cuántas soluciones le dominan y a cuántas dominan
"""

import numpy as np
import matplotlib.pyplot as plt

# Generar las soluciones no dominadas (código del paso 1)
soluciones_no_dominadas = []

for _ in range(100):
    solucion = np.random.uniform(low=[0, 100], high=[10, 1000])
    soluciones_no_dominadas.append(solucion)

soluciones_no_dominadas = np.array(soluciones_no_dominadas)

# Graficar las soluciones no dominadas (código del paso 2)
plt.scatter(soluciones_no_dominadas[:, 0], soluciones_no_dominadas[:, 1], color='blue', label='Soluciones no dominadas')

def generar_soluciones_dominantes(soluciones_no_dominadas, num_soluciones_dominantes):
    soluciones_dominantes = []
    for _ in range(num_soluciones_dominantes):
        solucion_dominante = np.random.uniform(low=[0, 100], high=[10, 1000])
        # Verificar si la solución dominante domina al menos a una solución no dominada
        soluciones_dominadas = []
        for solucion_no_dominada in soluciones_no_dominadas:
            if solucion_dominante[0] >= solucion_no_dominada[0] and solucion_dominante[1] <= solucion_no_dominada[1]:
                soluciones_dominadas.append(solucion_no_dominada)
        if len(soluciones_dominadas) > 0:
            soluciones_dominantes.append(solucion_dominante)
    return soluciones_dominantes

# Obtener 5 soluciones dominantes
soluciones_dominantes = generar_soluciones_dominantes(soluciones_no_dominadas, 5)

# Calcular para cada solución dominante cuántas soluciones le dominan y a cuántas soluciones domina
num_soluciones_dominantes = []
num_soluciones_dominadas = []
for solucion_dominante in soluciones_dominantes:
    num_dominantes = 0
    num_dominadas = 0
    for solucion_no_dominada in soluciones_no_dominadas:
        if solucion_dominante[0] >= solucion_no_dominada[0] and solucion_dominante[1] <= solucion_no_dominada[1]:
            num_dominantes += 1
        if solucion_dominante[0] <= solucion_no_dominada[0] and solucion_dominante[1] >= solucion_no_dominada[1]:
            num_dominadas += 1
    num_soluciones_dominantes.append(num_dominantes)
    num_soluciones_dominadas.append(num_dominadas)

# Añadir las soluciones dominantes al gráfico anterior, representándolas en otro color
plt.scatter([solucion[0] for solucion in soluciones_dominantes], [solucion[1] for solucion in soluciones_dominantes], color='red', label='Soluciones dominantes')

# Mostrar leyenda y título
plt.legend()
plt.title('Soluciones no dominadas y soluciones dominantes')

# Mostrar el gráfico
plt.show()

# Imprimir el número de soluciones que domina cada solución dominante
print("Información de las soluciones dominantes:")
for i, solucion_dominante in enumerate(soluciones_dominantes):
    print(f"Solución dominante {i+1}:")
    print(f"Número de soluciones que domina: {num_soluciones_dominantes[i]}")
    print(f"Número de soluciones dominadas por esta solución: {num_soluciones_dominadas[i]}")
    print()

"""# 4) 
Suponiendo que tenemos un problema de optimización con dos objetivos (Min,
Min), cuyos valores se encuentran en el rango [0,10], generar con Python 100
soluciones no dominadas (en el espacio de los objetivos) y representarlas
gráficamente.
"""

import numpy as np
import matplotlib.pyplot as plt

# Definir la función de dominancia
def es_dominante(solucion, poblacion):
    for p in poblacion:
        if np.all(p <= solucion) and np.any(p < solucion):
            return False
    return True

# Generar 100 soluciones no dominadas
soluciones_no_dominadas = []
poblacion = np.random.uniform(0, 10, size=(1000, 2))

for solucion in poblacion:
    if es_dominante(solucion, soluciones_no_dominadas):
        soluciones_no_dominadas.append(solucion)
        if len(soluciones_no_dominadas) == 100:
            break

soluciones_no_dominadas = np.array(soluciones_no_dominadas)

# Representar las soluciones gráficamente
plt.scatter(soluciones_no_dominadas[:, 0], soluciones_no_dominadas[:, 1], c='b', marker='o')

# Configurar etiquetas y título del gráfico
plt.xlabel('Objetivo 1')
plt.ylabel('Objetivo 2')
plt.title('Soluciones no dominadas')

# Mostrar el gráfico
plt.show()

import random
import matplotlib.pyplot as plt

# Generar una solución aleatoria en el espacio de objetivos
def generar_solucion():
    objetivo1 = random.uniform(0, 10)
    objetivo2 = random.uniform(0, 10)
    return (objetivo1, objetivo2)

# Comprobar si una solución domina a otra
def domina(solucion1, solucion2):
    return solucion1[0] <= solucion2[0] and solucion1[1] <= solucion2[1]

# Generar soluciones no dominadas
def generar_soluciones_no_dominadas(soluciones):
    soluciones_no_dominadas = []
    for solucion in soluciones:
        if not any(domina(solucion, otra_solucion) for otra_solucion in soluciones_no_dominadas):
            soluciones_no_dominadas.append(solucion)
    return soluciones_no_dominadas

# Generar soluciones aleatorias hasta obtener 100 soluciones no dominadas
soluciones = []
while len(soluciones) < 100:
    solucion = generar_solucion()
    if not any(domina(solucion, otra_solucion) for otra_solucion in soluciones):
        soluciones.append(solucion)

# Obtener las soluciones no dominadas
soluciones_no_dominadas = generar_soluciones_no_dominadas(soluciones)

# Representar gráficamente las soluciones no dominadas
objetivo1 = [solucion[0] for solucion in soluciones_no_dominadas]
objetivo2 = [solucion[1] for solucion in soluciones_no_dominadas]

plt.scatter(objetivo1, objetivo2, c='blue', marker='o')
plt.xlabel('Objetivo 1')
plt.ylabel('Objetivo 2')
plt.title('Soluciones No Dominadas')
plt.grid(True)
plt.show()

"""# 5) 
Obtener 5 soluciones (en el espacio de los objetivos) dominadas por algunas de las soluciones generadas en 4) y añadirlas al gráfico anterior, representándolas en otro color. Determinar, para cada una de estas 5 soluciones, cuántas soluciones le dominan y a cuántas dominan
"""

# Obtener 5 soluciones dominadas por alguna de las soluciones no dominadas
soluciones_dominadas = []
for solucion in soluciones_no_dominadas:
    if any(domina(otra_solucion, solucion) for otra_solucion in soluciones if otra_solucion != solucion):
        soluciones_dominadas.append(solucion)
        if len(soluciones_dominadas) == 5:
            break

# Representar gráficamente las soluciones dominadas
objetivo1_dominadas = [solucion[0] for solucion in soluciones_dominadas]
objetivo2_dominadas = [solucion[1] for solucion in soluciones_dominadas]
plt.scatter(objetivo1_dominadas, objetivo2_dominadas, label='Soluciones Dominadas', color='green')

# Calcular cuántas soluciones dominan y a cuántas dominan las soluciones dominadas
for i, solucion_dominada in enumerate(soluciones_dominadas):
    num_soluciones_dominantes = sum(domina(solucion, solucion_dominada) for solucion in soluciones)
    num_soluciones_dominadas = sum(domina(solucion_dominada, solucion) for solucion in soluciones)
    print(f"La solución dominada {i+1} es dominada por {num_soluciones_dominantes} soluciones y domina a {num_soluciones_dominadas} soluciones.")

# Actualizar el gráfico
plt.xlabel('Objetivo 1')
plt.ylabel('Objetivo 2')
plt.legend()
plt.title('Representación gráfica de las soluciones')
plt.show()

import random
import matplotlib.pyplot as plt

# Generar una solución aleatoria en el espacio de objetivos
def generar_solucion():
    objetivo1 = random.uniform(0, 10)
    objetivo2 = random.uniform(0, 10)
    return (objetivo1, objetivo2)

# Comprobar si una solución domina a otra
def domina(solucion1, solucion2):
    return solucion1[0] <= solucion2[0] and solucion1[1] <= solucion2[1]

# Generar soluciones no dominadas
def generar_soluciones_no_dominadas(soluciones):
    soluciones_no_dominadas = []
    for solucion in soluciones:
        if not any(domina(solucion, otra_solucion) for otra_solucion in soluciones_no_dominadas):
            soluciones_no_dominadas.append(solucion)
    return soluciones_no_dominadas

# Generar soluciones aleatorias hasta obtener 100 soluciones no dominadas
soluciones = []
while len(soluciones) < 100:
    solucion = generar_solucion()
    if not any(domina(solucion, otra_solucion) for otra_solucion in soluciones):
        soluciones.append(solucion)

# Obtener las soluciones no dominadas
soluciones_no_dominadas = generar_soluciones_no_dominadas(soluciones)

# Representar gráficamente las soluciones no dominadas
objetivo1 = [solucion[0] for solucion in soluciones_no_dominadas]
objetivo2 = [solucion[1] for solucion in soluciones_no_dominadas]

plt.scatter(objetivo1, objetivo2, c='blue', marker='o')

# Obtener 5 soluciones dominadas
soluciones_dominadas = []
for _ in range(5):
    solucion = generar_solucion()
    while not any(domina(solucion_no_dominada, solucion) for solucion_no_dominada in soluciones_no_dominadas):
        solucion = generar_solucion()
    soluciones_dominadas.append(solucion)

# Obtener el número de soluciones que dominan y que son dominadas por cada una de las soluciones dominadas
num_soluciones_dominadas = [sum(domina(solucion_dominada, solucion_no_dominada) for solucion_no_dominada in soluciones_no_dominadas) for solucion_dominada in soluciones_dominadas]
num_soluciones_que_dominan = [sum(domina(solucion_no_dominada, solucion_dominada) for solucion_no_dominada in soluciones_no_dominadas) for solucion_dominada in soluciones_dominadas]

# Agregar las soluciones dominadas al gráfico
objetivo1_dominadas = [solucion[0] for solucion in soluciones_dominadas]
objetivo2_dominadas = [solucion[1] for solucion in soluciones_dominadas]

plt.scatter(objetivo1_dominadas, objetivo2_dominadas, c='red', marker='o')

plt.xlabel('Objetivo 1')
plt.ylabel('Objetivo 2')
plt.title('Soluciones No Dominadas y Dominadas')
plt.grid(True)
plt.show()

# Imprimir
for i, solucion in enumerate(soluciones_dominadas):
    print(f"Solución {i+1}: {num_soluciones_dominadas[i]} soluciones le dominan, {num_soluciones_que_dominan[i]} soluciones domina")

"""# 6) 
Obtener 5 soluciones (en el espacio de los objetivos) que dominen a algunas de las soluciones generadas en 4) y añadirlas al gráfico anterior, representándolas en otro color. Determinar, para cada una de estas 5 soluciones, cuántas soluciones le dominan y a cuántas dominan.
"""

# Obtener 5 soluciones que dominen a algunas de las soluciones no dominadas
soluciones_dominantes = []
for solucion in soluciones:
    if any(domina(solucion, otra_solucion) for otra_solucion in soluciones_no_dominadas):
        soluciones_dominantes.append(solucion)
        if len(soluciones_dominantes) == 5:
            break

# Representar gráficamente las soluciones dominantes
objetivo1_dominantes = [solucion[0] for solucion in soluciones_dominantes]
objetivo2_dominantes = [solucion[1] for solucion in soluciones_dominantes]
plt.scatter(objetivo1_dominantes, objetivo2_dominantes, label='Soluciones Dominantes', color='purple')

# Calcular cuántas soluciones dominan y a cuántas dominan las soluciones dominantes
for i, solucion_dominante in enumerate(soluciones_dominantes):
    num_soluciones_dominantes = sum(domina(solucion, solucion_dominante) for solucion in soluciones)
    num_soluciones_dominadas = sum(domina(solucion_dominante, solucion) for solucion in soluciones)
    print(f"La solución dominante {i+1} domina a {num_soluciones_dominantes} soluciones y es dominada por {num_soluciones_dominadas} soluciones.")

# Actualizar el gráfico
plt.xlabel('Objetivo 1')
plt.ylabel('Objetivo 2')
plt.legend()
plt.title('Representación gráfica de las soluciones')
plt.show()

import random
import matplotlib.pyplot as plt

# Generar una solución aleatoria en el espacio de objetivos
def generar_solucion():
    objetivo1 = random.uniform(0, 10)
    objetivo2 = random.uniform(0, 10)
    return (objetivo1, objetivo2)

# Comprobar si una solución domina a otra
def domina(solucion1, solucion2):
    return solucion1[0] <= solucion2[0] and solucion1[1] <= solucion2[1]

# Generar soluciones no dominadas
def generar_soluciones_no_dominadas(soluciones):
    soluciones_no_dominadas = []
    for solucion in soluciones:
        if not any(domina(solucion, otra_solucion) for otra_solucion in soluciones_no_dominadas):
            soluciones_no_dominadas.append(solucion)
    return soluciones_no_dominadas

# Generar soluciones aleatorias hasta obtener 100 soluciones no dominadas
soluciones = []
while len(soluciones) < 100:
    solucion = generar_solucion()
    if not any(domina(solucion, otra_solucion) for otra_solucion in soluciones):
        soluciones.append(solucion)

# Obtener las soluciones no dominadas
soluciones_no_dominadas = generar_soluciones_no_dominadas(soluciones)

# Representar gráficamente las soluciones no dominadas
objetivo1 = [solucion[0] for solucion in soluciones_no_dominadas]
objetivo2 = [solucion[1] for solucion in soluciones_no_dominadas]

plt.scatter(objetivo1, objetivo2, c='blue', marker='o')

# Obtener 5 soluciones que dominen a algunas de las soluciones no dominadas
soluciones_dominantes = []
for _ in range(5):
    solucion = generar_solucion()
    while not any(domina(solucion_no_dominada, solucion) for solucion_no_dominada in soluciones_no_dominadas):
        solucion = generar_solucion()
    soluciones_dominantes.append(solucion)

# Obtener el número de soluciones que dominan y que son dominadas por cada una de las soluciones dominantes
num_soluciones_dominantes = [sum(domina(solucion_no_dominada, solucion_dominante) for solucion_no_dominada in soluciones_no_dominadas) for solucion_dominante in soluciones_dominantes]
num_soluciones_dominadas = [sum(domina(solucion_dominante, solucion_no_dominada) for solucion_no_dominada in soluciones_no_dominadas) for solucion_dominante in soluciones_dominantes]

# Agregar las soluciones dominantes al gráfico
objetivo1_dominantes = [solucion[0] for solucion in soluciones_dominantes]
objetivo2_dominantes = [solucion[1] for solucion in soluciones_dominantes]

plt.scatter(objetivo1_dominantes, objetivo2_dominantes, c='red', marker='o')

plt.xlabel('Objetivo 1')
plt.ylabel('Objetivo 2')
plt.title('Soluciones No Dominadas y Dominantes')
plt.grid(True)
plt.show()

# Imprimir el número de soluciones que dominan y que son dominadas por cada una de las soluciones dominantes
for i, solucion in enumerate(soluciones_dominantes):
    print(f"Solución {i+1}: {num_soluciones_dominantes[i]} soluciones le dominan, {num_soluciones_dominadas[i]} soluciones domina")

"""# 7) 
Suponiendo que tenemos un problema de optimización con tres objetivos (Min,
Max, Min), cuyos valores se encuentran en el rango [0,10], generar con Python
100 soluciones no dominadas (en el espacio de los objetivos) y representarlas
gráficamente.

"""

def generar_solucion():
    objetivo1 = random.uniform(0, 10)
    objetivo2 = random.uniform(0, 10)
    objetivo3 = random.uniform(0, 10)
    return (objetivo1, objetivo2, objetivo3)

# Comprobar si una solución domina a otra
def domina(solucion1, solucion2):
    return solucion1[0] <= solucion2[0] and solucion1[1] >= solucion2[1] and solucion1[2] <= solucion2[2]

# Generar soluciones no dominadas
def generar_soluciones_no_dominadas(soluciones):
    soluciones_no_dominadas = []
    for solucion in soluciones:
        if not any(domina(solucion, otra_solucion) for otra_solucion in soluciones_no_dominadas):
            soluciones_no_dominadas.append(solucion)
            if len(soluciones_no_dominadas) == 100:
                break
    return soluciones_no_dominadas

# Generar soluciones aleatorias hasta obtener 100 soluciones no dominadas
soluciones = []
while len(soluciones) < 100:
    solucion = generar_solucion()
    if not any(domina(solucion, otra_solucion) for otra_solucion in soluciones):
        soluciones.append(solucion)

# Obtener las soluciones no dominadas
soluciones_no_dominadas = generar_soluciones_no_dominadas(soluciones)

# Representar gráficamente las soluciones no dominadas
objetivo1 = [solucion[0] for solucion in soluciones_no_dominadas]
objetivo2 = [solucion[1] for solucion in soluciones_no_dominadas]
objetivo3 = [solucion[2] for solucion in soluciones_no_dominadas]

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.scatter(objetivo1, objetivo2, objetivo3, c='red', marker='o')

ax.set_xlabel('Objetivo 1')
ax.set_ylabel('Objetivo 2')
ax.set_zlabel('Objetivo 3')

plt.title('Representación gráfica de las 100 soluciones no dominadas')
plt.show()

"""# 8) 
Obtener 5 soluciones (en el espacio de los objetivos) dominadas por algunas de las soluciones generadas en 7) y añadirlas al gráfico anterior, representándolas en otro color. Determinar, para cada una de estas 5 soluciones, cuántas soluciones le dominan y a cuántas dominan.

"""

import random
import matplotlib.pyplot as plt

# Generar una solución aleatoria en el espacio de objetivos
def generar_solucion():
    objetivo1 = random.uniform(0, 10)
    objetivo2 = random.uniform(0, 10)
    objetivo3 = random.uniform(0, 10)
    return (objetivo1, objetivo2, objetivo3)

# Comprobar si una solución domina a otra
def domina(solucion1, solucion2):
    return solucion1[0] <= solucion2[0] and solucion1[1] >= solucion2[1] and solucion1[2] <= solucion2[2]

# Generar soluciones no dominadas
def generar_soluciones_no_dominadas(soluciones):
    soluciones_no_dominadas = []
    for solucion in soluciones:
        if not any(domina(solucion, otra_solucion) for otra_solucion in soluciones_no_dominadas):
            soluciones_no_dominadas.append(solucion)
    return soluciones_no_dominadas

# Generar soluciones aleatorias hasta obtener 100 soluciones no dominadas
soluciones = []
while len(soluciones) < 100:
    solucion = generar_solucion()
    if not any(domina(solucion, otra_solucion) for otra_solucion in soluciones):
        soluciones.append(solucion)

# Obtener las soluciones no dominadas
soluciones_no_dominadas = generar_soluciones_no_dominadas(soluciones)

# Representar gráficamente las soluciones no dominadas
objetivo1 = [solucion[0] for solucion in soluciones_no_dominadas]
objetivo2 = [solucion[1] for solucion in soluciones_no_dominadas]
objetivo3 = [solucion[2] for solucion in soluciones_no_dominadas]

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.scatter(objetivo1, objetivo2, objetivo3, c='red', marker='o')

ax.set_xlabel('Objetivo 1')
ax.set_ylabel('Objetivo 2')
ax.set_zlabel('Objetivo 3')

# Obtener 5 soluciones dominadas por las soluciones no dominadas existentes
soluciones_dominadas = []
for _ in range(5):
    solucion = generar_solucion()
    soluciones_dominadas.append(solucion)

    # Comprobar cuántas soluciones dominan y cuántas son dominadas por la solución actual
    dominadas_por_solucion = sum(domina(solucion, otra_solucion) for otra_solucion in soluciones_no_dominadas)
    dominan_a_solucion = sum(domina(otra_solucion, solucion) for otra_solucion in soluciones_no_dominadas)
    print(f'Solución: {solucion} - Dominadas por: {dominadas_por_solucion} - Dominan a: {dominan_a_solucion}')

# Agregar las soluciones dominadas al gráfico
dominado1 = [solucion[0] for solucion in soluciones_dominadas]
dominado2 = [solucion[1] for solucion in soluciones_dominadas]
dominado3 = [solucion[2] for solucion in soluciones_dominadas]
ax.scatter(dominado1, dominado2, dominado3, c='blue', marker='o')

plt.show()

"""# 9) 
Obtener 5 soluciones (en el espacio de los objetivos) que dominen a algunas de las soluciones generadas en 7) y añadirlas al gráfico anterior, representándolas en otro color. Determinar, para cada una de estas 5 soluciones, cuántas soluciones le dominan y a cuántas dominan.
"""

import random
import matplotlib.pyplot as plt

# Generar una solución aleatoria en el espacio de objetivos
def generar_solucion():
    objetivo1 = random.uniform(0, 10)
    objetivo2 = random.uniform(0, 10)
    objetivo3 = random.uniform(0, 10)
    return (objetivo1, objetivo2, objetivo3)

# Comprobar si una solución domina a otra
def domina(solucion1, solucion2):
    return solucion1[0] <= solucion2[0] and solucion1[1] >= solucion2[1] and solucion1[2] <= solucion2[2]

# Generar soluciones no dominadas
def generar_soluciones_no_dominadas(soluciones):
    soluciones_no_dominadas = []
    for solucion in soluciones:
        if not any(domina(solucion, otra_solucion) for otra_solucion in soluciones_no_dominadas):
            soluciones_no_dominadas.append(solucion)
    return soluciones_no_dominadas

# Generar soluciones aleatorias hasta obtener 100 soluciones no dominadas
soluciones = []
while len(soluciones) < 100:
    solucion = generar_solucion()
    if not any(domina(solucion, otra_solucion) for otra_solucion in soluciones):
        soluciones.append(solucion)

# Obtener las soluciones no dominadas
soluciones_no_dominadas = generar_soluciones_no_dominadas(soluciones)

# Representar gráficamente las soluciones no dominadas
objetivo1 = [solucion[0] for solucion in soluciones_no_dominadas]
objetivo2 = [solucion[1] for solucion in soluciones_no_dominadas]
objetivo3 = [solucion[2] for solucion in soluciones_no_dominadas]

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.scatter(objetivo1, objetivo2, objetivo3, c='red', marker='o')

ax.set_xlabel('Objetivo 1')
ax.set_ylabel('Objetivo 2')
ax.set_zlabel('Objetivo 3')

# Obtener 5 soluciones que dominen a algunas de las soluciones no dominadas existentes
soluciones_dominantes = []
for _ in range(5):
    solucion = generar_solucion()
    
    # Comprobar si la solución domina a alguna de las soluciones no dominadas
    dominadas_por_solucion = [sol for sol in soluciones_no_dominadas if domina(solucion, sol)]
    
    # Si hay al menos una solución dominada, se agrega a la lista de soluciones dominantes
    if dominadas_por_solucion:
        soluciones_dominantes.append(solucion)
        
        # Imprimir el número de soluciones dominadas y el número de soluciones que domina la solución actual
        print(f'Solución: {solucion} - Soluciones dominadas: {len(dominadas_por_solucion)}')
        
# Agregar las soluciones dominantes al gráfico
dominante1 = [solucion[0] for solucion in soluciones_dominantes]
dominante2 = [solucion[1] for solucion in soluciones_dominantes]
dominante3 = [solucion[2] for solucion in soluciones_dominantes]

ax.scatter(dominante1, dominante2, dominante3, c='blue', marker='o')

# Generar 5 soluciones adicionales
soluciones_adicionales = []
for _ in range(5):
    solucion = generar_solucion()
    soluciones_adicionales.append(solucion)

# Agregar las soluciones adicionales al gráfico
adicional1 = [solucion[0] for solucion in soluciones_adicionales]
adicional2 = [solucion[1] for solucion in soluciones_adicionales]
adicional3 = [solucion[2] for solucion in soluciones_adicionales]

ax.scatter(adicional1, adicional2, adicional3, c='green', marker='o')

plt.show()